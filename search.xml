<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>colab</title>
      <link href="/2023/08/09/colab/"/>
      <url>/2023/08/09/colab/</url>
      
        <content type="html"><![CDATA[<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="防停脚本"><a href="#防停脚本" class="headerlink" title="防停脚本"></a>防停脚本</h3><p>在浏览器 console 输入如下脚本</p><pre class="line-numbers language-none"><code class="language-none">function ClickConnect()&#123;  colab.config  console.log(&quot;Connnect Clicked - Start&quot;);   document.querySelector(&quot;#top-toolbar &gt; colab-connect-button&quot;).shadowRoot.querySelector(&quot;#connect&quot;).click();  console.log(&quot;Connnect Clicked - End&quot;);&#125;;setInterval(ClickConnect, 60000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就可以每隔60秒点击一次页面，防止 colab 因为检测到挂机而切断和服务器的连接</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ai homework</title>
      <link href="/2023/08/07/ai-homework/"/>
      <url>/2023/08/07/ai-homework/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>搬运一下人工智能的实验作业，有些题目还是思考了很久的，也汇聚了很多同学的想法。如果读者有其它想法欢迎评论：</p><ul><li>题目一：astar 搜索<br>对于一个初始的随机 01 方阵，每次可以将一个 L 型区域的三个数字的 01 翻转，目标状态为全部为 0 的方阵，问以什么步骤翻转能使翻转次数最少<pre class="line-numbers language-none"><code class="language-none">1 1 1        0 0 1       0 1 0       0 0 01 1 0 --&gt;&gt;   1 0 0 --&gt;&gt;  1 1 0 --&gt;&gt;  0 0 0 (解锁成功)0 0 0        0 0 0       0 0 0       0 0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>题目二：CSP 约束满足问题<br>为学校的宿管阿姨安排⼀个值班表，以满⾜给定的约束条件，并尽可能满⾜阿姨们的轮班请求</li></ul><p>详细题目见文档：</p><p><a href="exp.pdf" class='download' download="exp">ai homework.pdf</a></p><h2 id="exp1-1"><a href="#exp1-1" class="headerlink" title="exp1.1"></a>exp1.1</h2><h3 id="启发式函数选择"><a href="#启发式函数选择" class="headerlink" title="启发式函数选择"></a>启发式函数选择</h3><h4 id="不包含局部信息的启发式函数"><a href="#不包含局部信息的启发式函数" class="headerlink" title="不包含局部信息的启发式函数"></a>不包含局部信息的启发式函数</h4><ul><li><p>一个显然的启发式函数是$h_1=\lceil\frac{1的总数}{3}\rceil$</p><p>  它实际上把本题松弛到了 <em>每次可以翻转锁盘上的任意1、2或3个数</em> ，比原题的要求低了很多，所以是<strong>可采纳的</strong></p><p>  下面考虑<strong>证明其一致性</strong>：<br>设当前局面为$n$，代价 $h_1(n)=\lceil\frac{n中1的总数}{3}\rceil$，下一步实际能做的是翻转一个L形，到达局面$n’$。它可能把3个1翻转到0，因此 $h_1(n’)=\lceil\frac{n中1的总数-3}{3}\rceil=\lceil\frac{n中1的总数}{3}\rceil-1$ ；也有可能把几个1翻转到0并把几个0翻转到1，那么此时 $h_1(n’)\geq\lceil\frac{n中1的总数}{3}\rceil-1$<br>综上有 $h_1(n’)+1\geq h_1(n)$，满足三角不等式，故有一致性</p></li><li><p>同理$h_2=\frac{1的总数}{3}$也是一个启发式<br>显然$h_2\leq h_1$，$h_1$已然是可采纳的，那么$h_2$也是<strong>可采纳的</strong>。同理也可以证明$h_2$的<strong>一致性</strong></p></li></ul><p>比较$h_1$与$h_2$的优劣：<br>$h_1$更大，所以理论上会更占优势。但是$h_1$的取整导致它可能对细微的变化不够敏感：如果某一节点将要展开的子节点中1的总数为28、29、30，那么$h_1$将看不出它们之间有什么区别，从而随便选择一个子节点展开。而$h_2$可以区分它们的好坏。</p><h4 id="包含局部信息的启发式函数"><a href="#包含局部信息的启发式函数" class="headerlink" title="包含局部信息的启发式函数"></a>包含局部信息的启发式函数</h4><p>以上两个启发式都是翻转锁盘上的任意位置，这和原问题的L形约束相差较远</p><p>下面这种分散的情况期望用一次操作解决就太过乐观了。所以需要观察1的排布是否有局部性</p><pre class="line-numbers language-none"><code class="language-none">1 0 0 00 0 0 00 0 0 11 0 0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面这种虽然集中在一起，但是由于不是L形，也不能期望用一次操作解决。所以要合理定义局部，不能太大或太小</p><pre class="line-numbers language-none"><code class="language-none">0 0 0 00 1 1 10 0 0 00 0 0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>只有这种局部性才是能够一次操作解决的：</p><pre class="line-numbers language-none"><code class="language-none">0 0 0 00 1 1 00 1 0 00 0 0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>考虑用<strong>尽可能少</strong>的2×2的方块来覆盖锁盘上所有的1，方块之间可以重叠，此时方块的数量定义为$h_3$</p><p>上面的例子中$h_3$的值分别为3、2、1<br>而譬如</p><pre class="line-numbers language-none"><code class="language-none">0 1 01 1 11 1 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>$h_3$值为2，两个方块重叠了一部分，并且这也是实际的值</p><p>下面<strong>证明它是可采纳的</strong>：<br>它把原问题松弛成了 <em>每一步可以翻转一个2×2方块中的1到4个数字*，那么到最优解的代价就是用尽可能少的方块数量。而之所以称其为松弛，是因为只有 *每一步翻转一个2×2方块中的3个数字</em> 和是原问题的约束一样，而 <em>每一步翻转一个2×2方块中的1、2、4个数字</em> 是在原问题下需要很多步才能办到的事情。所以是可采纳的。</p><p>下面<strong>证明它是一致的</strong>：<br>设当前局面为$n$，下一步实际能做的是翻转一个L形，到达局面$n’$<br>反证其不一致，就是要求 $h_3(n’)+1 &lt; h_3(n)$，即 $h_3(n’) \leq h_3(n)-2$，即翻转一个L形之后，$n’$比$n$少了2个覆盖方块（或者更多）<br>考虑这个L形在$n$中的位置：</p><ul><li>如果它刚好在某个方块上，那么翻转它只会影响该方块，不会少两个覆盖方块</li><li>如果它和两或三个方块都有重叠，那么翻转它时会影响多个方块，但是通过枚举简单情况，可以发现这些被影响的方块不会被同时清零，也即$n’$比$n$最多就少了1个覆盖方块<br>综上得证一致性</li></ul></li><li><p>但是寻找这个最少方块的个数并不是容易的事。可以用简单的贪心算法得出一个较少的解，设该解为$h_4$</p><pre class="line-numbers language-none"><code class="language-none">输入：初始锁盘M输出：方块个数numnum &#x3D; 0repeat:    尝试2*2方块在M中的所有摆放情况，得到覆盖最大1的个数max_n和位置loc    if max_n &#x3D;&#x3D; 0        return num    else        num &#x3D; num + 1        将loc内所有元素变为0，更新M    重置max_n和loc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个算法在<code>尝试</code>步骤用时$O(n^2)$，总共循环次数$O(方块个数)$，总占用空间$O(n^2)$，可以说计算代价相当小了</p><p>可以找到例子说明$h_4$并<strong>不可采纳</strong>，比如下面的例子$h_4=3$，$h_3=2$，实际估计代价也是2</p><pre class="line-numbers language-none"><code class="language-none">0 1 1 01 1 1 10 0 0 00 0 0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是对于<strong>大多数情况</strong>来说，$h_4\geq h_3$并不意味着$h_4\geq 实际估计代价$，因为$h_3$确实很小，足以满足$实际估计代价\geq h_4\geq h_3$</p></li></ul><p>比较这些启发式函数在5*5样例上的运行结果：</p><table><thead><tr><th>对input0（5*5）</th><th>$h_1$</th><th>$h_2$</th><th>$h_4$</th></tr></thead><tbody><tr><td>总展开节点</td><td>789</td><td>2846</td><td>200</td></tr><tr><td>解的步数</td><td>5</td><td>5</td><td>5</td></tr></tbody></table><table><thead><tr><th>对input3（5*5）</th><th>$h_1$</th><th>$h_2$</th><th>$h_4$</th></tr></thead><tbody><tr><td>总展开节点</td><td>3791</td><td>14922</td><td>342</td></tr><tr><td>解的步数</td><td>7</td><td>7</td><td>7</td></tr></tbody></table><table><thead><tr><th>对input4（5*5）</th><th>$h_1$</th><th>$h_2$</th><th>$h_4$</th></tr></thead><tbody><tr><td>总展开节点</td><td>129612</td><td>–</td><td>13502</td></tr><tr><td>解的步数</td><td>9</td><td>–</td><td>9</td></tr></tbody></table><table><thead><tr><th>对input5（5*5）</th><th>$h_1$</th><th>$h_2$</th><th>$h_4$</th></tr></thead><tbody><tr><td>总展开节点</td><td>26751</td><td>27254</td><td>394</td></tr><tr><td>解的步数</td><td>7</td><td>7</td><td>7</td></tr></tbody></table><p>可以发现$h_4$大约优于$h_1$ 10倍，而$h_2$比$h_1$更差<br>这说明了对于可采纳且一致的启发式，越大的启发式意味着越占优势</p><p>但是这三个启发式在面对更大的图的时候并不管用，需要寻找新的启发式</p><h4 id="不可采纳的启发式"><a href="#不可采纳的启发式" class="headerlink" title="不可采纳的启发式"></a>不可采纳的启发式</h4><p>如果对于比较大的图，追求很快求出一个比较好的解，那么调大启发式（以至于其不可采纳）是一个不错的选择</p><p>如果采用不可采纳的启发式 $2*h_4$ 那么有</p><table><thead><tr><th>$2*h_4$</th><th>input6 (9*9)</th><th>input7 (9*9)</th><th>input8 (10*10)</th><th>input9 (12*12)</th></tr></thead><tbody><tr><td>总展开节点数</td><td>27</td><td>117</td><td>24</td><td>190</td></tr><tr><td>解的步数</td><td>11</td><td>16</td><td>16</td><td>23</td></tr><tr><td>最优解步数</td><td>11</td><td>14</td><td>16</td><td>23</td></tr></tbody></table><p>可以发现其中有的解的步数和总展开节点数都相差不大的，这说明此时搜索算法向深拓展了很多，而向宽没怎么拓展。这是因为 g+h 中 h 已经大于 g 不少，导致解的深度 g 的惩罚显得不是很厉害。而考虑到这题的性质：无论什么图都是有解的，所以算法可以<em>一条路走到黑</em>，而不用担心进入死胡同</p><p>显然 $ 2 * h_4 $ 的 $2$ 是随便取的，那么可以尝试调参 $\alpha * h_4，\alpha\geq1$ ，以尝试每种input的解的最小步数</p><table><thead><tr><th>$1.5*h_4$</th><th>input6 (9*9)</th><th>input7 (9*9)</th><th>input8 (10*10)</th><th>input9 (12*12)</th></tr></thead><tbody><tr><td>总展开节点数</td><td>45</td><td>2105</td><td>40</td><td>1759</td></tr><tr><td>解的步数</td><td>11</td><td>16</td><td>16</td><td>23</td></tr><tr><td>最优解步数</td><td>11</td><td>14</td><td>16</td><td>23</td></tr></tbody></table><p><em>可以发现input7和input9的展开节点数显著上升，这暗示了这个启发式的搜索空间明显更大了，也就是前一个启发式漏掉了更多的应该被检查的节点</em></p><p>但是这件事可以做得更细腻一点：<strong>我们可以尝试出一个 $\alpha(M)*h_4$，使得它恰好是当前锁盘$M$的预期代价的一个下界</strong>，其中$\alpha(M)$是锁盘$M$的一个函数，这样A<em>算法的启发式函数就可以*</em>自始至终都满足可采纳性**了<br>关于$\alpha(M)$的选择，有几个观察：</p><ul><li>$对\forall M，\alpha(M)=1$时，$\alpha(M)*h_4$是$M$预期代价的下界，只不过太小了，展开节点数很多</li><li>$\alpha(M)*h_4$越接近$M$的预期代价，则展开节点数越少，所以$\alpha(M)$要尽可能大，但是不能高估预期代价</li><li>$M$越复杂（可以用1的数目做度量），$h_4$与预期代价之间的差额就越大，就可以尝试更大的$\alpha(M)$</li><li>上面这个观察是对平均而言，而对于具体的$M$和$\alpha(M)$，有可能会找到违背可采纳性的反例，所以这个可采纳性是对平均而言的，可以称之为<strong>平均可采纳性</strong></li></ul><p>比如采用$\frac{M中1的总数}{锁盘格子总数}+1$作为$\alpha(M)$，它的值域在$[2,1]$并且满足上述条件</p><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><h4 id="解的上界"><a href="#解的上界" class="headerlink" title="解的上界"></a>解的上界</h4><p>下面证明任意一个2*2以上大小的锁盘都是有解的，先从一个点的情况考虑：</p><pre class="line-numbers language-none"><code class="language-none">0 0      1 1      1 0      0 01 0  -&gt;  0 0  -&gt;  1 1  -&gt;  0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可见在这三次操作里面，左下角的点翻转了3次，其它点翻转了2次。所以只有左下角的点被改变了。<br>那么对于一个任意的棋盘，我们对每个点都如此操作即可</p><p>所以可以得出$解的上界=1的总数*3$</p><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>对于某个锁盘的局面进行某个翻转时，有可能是将三个0翻转成三个1，这种展开显然是多余的。启发式函数可能对这种情况给与比其它情况更大的惩罚，但是也有可能不会这样。所以需要直接限定不能将三个0翻转成三个1。</p><p>这种带来的剪枝是很可观的：</p><table><thead><tr><th>对input0（5*5） 启发式$h_1$</th><th>剪枝</th><th>不剪枝</th></tr></thead><tbody><tr><td>总展开节点</td><td>789</td><td>4330</td></tr><tr><td>解的步数</td><td>5</td><td>5</td></tr></tbody></table><h4 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h4><p>首先介绍算法中定义的结构体：<br>矩阵结构体：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Matrix</span><span class="token punctuation">&#123;</span>       vector<span class="token operator">&lt;</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">></span> a<span class="token punctuation">;</span>      <span class="token function">Matrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>      <span class="token comment">//在p的基础上通过i,j,s变化生成新矩阵，此处i,j,s需要合法，如果此时将三个0翻成三个1，则设useless为true</span>      <span class="token function">Matrix</span><span class="token punctuation">(</span>Matrix p<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token operator">&amp;</span>useless<span class="token punctuation">)</span>      <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span>Matrix x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它包含成员变量<code>a</code>表示锁盘内容<br>定义了在p的基础上通过i,j,s变化生成新矩阵的构造函数，并且可以判断该变化需不需要剪枝<br>重载了<code>&lt;</code>以使用c++的数据结构</p><p>矩阵状态结构体：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MatrixState</span><span class="token punctuation">&#123;</span> Matrix m<span class="token punctuation">;</span><span class="token keyword">int</span> pos<span class="token punctuation">;</span> <span class="token comment">//记录状态编号 </span><span class="token keyword">int</span> g<span class="token punctuation">;</span> <span class="token comment">//到达此状态移动的步数</span><span class="token keyword">float</span> h<span class="token punctuation">;</span> <span class="token comment">//预期代价</span><span class="token function">MatrixState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token comment">//创建新矩阵状态，并按照h_func计算h</span><span class="token function">MatrixState</span><span class="token punctuation">(</span>Matrix x<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token punctuation">(</span><span class="token operator">*</span>h_func<span class="token punctuation">)</span><span class="token punctuation">(</span>Matrix M<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span>MatrixState x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它是A*算法中的每个节点的类型<br>包含矩阵结构体<code>m</code>，状态编号（回溯解时需要），以及该节点的g和h<br>定义了创建新矩阵状态的构造函数，并且可以指定新矩阵状态计算时的启发式函数</p><p>下面介绍算法流程：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//A*搜索，输入初始矩阵状态M，返回总步数step和最终结果在path中的下标cnt（后续以此回溯解路径）</span><span class="token keyword">void</span> <span class="token function">AstarSearch</span><span class="token punctuation">(</span>MatrixState MS<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>step<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>cnt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    set<span class="token operator">&lt;</span>Matrix<span class="token operator">></span> seen<span class="token punctuation">;</span> <span class="token comment">//用于判断状态矩阵是否重复的集合 </span>    priority_queue<span class="token operator">&lt;</span>MatrixState<span class="token operator">></span> OPEN<span class="token punctuation">;</span> <span class="token comment">//待展开的队列，按g+h从小到大排序</span>    <span class="token comment">//设置初始</span>    OPEN<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>MS<span class="token punctuation">)</span><span class="token punctuation">;</span>    seen<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>MS<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>MS<span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>OPEN<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//弹出第一个矩阵状态F</span>MatrixState F<span class="token operator">=</span>OPEN<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>OPEN<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断终止状态</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>F<span class="token punctuation">.</span>h<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>step<span class="token operator">=</span>F<span class="token punctuation">.</span>g<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">.</span>h<span class="token punctuation">)</span> cnt<span class="token operator">--</span><span class="token punctuation">;</span>                        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"总遍历节点："</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//展开所有节点</span>        <span class="token comment">//要按s分类，因为每种s对应一些i,j非法</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> s<span class="token operator">&lt;=</span><span class="token number">4</span><span class="token punctuation">;</span> s<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> i_start<span class="token punctuation">,</span> i_end<span class="token punctuation">,</span> j_start<span class="token punctuation">,</span> j_end<span class="token punctuation">;</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                i_start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                i_end <span class="token operator">=</span> Msize<span class="token punctuation">;</span>                j_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                j_end <span class="token operator">=</span> Msize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>                i_start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                i_end <span class="token operator">=</span> Msize<span class="token punctuation">;</span>                j_start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                j_end <span class="token operator">=</span> Msize<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>                i_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                i_end <span class="token operator">=</span> Msize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                j_start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                j_end <span class="token operator">=</span> Msize<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>                i_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                i_end <span class="token operator">=</span> Msize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                j_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                j_end <span class="token operator">=</span> Msize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> i_start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> i_end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> j_start<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> j_end<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token comment">//一种剪枝：如果当前把三个0翻成三个1，则useless为true</span>                    <span class="token keyword">bool</span> useless <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token comment">//展开当前节点</span>                    Matrix <span class="token function">new_m</span><span class="token punctuation">(</span>F<span class="token punctuation">.</span>m<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> s<span class="token punctuation">,</span> useless<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//如果seen集合中没有此矩阵，则更新seen，并插入OPEN队列</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>seen<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>new_m<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token punctuation">&#123;</span>                        seen<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>new_m<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//此状态的g是父节点F.g+1</span>                        MatrixState <span class="token function">new_MS</span><span class="token punctuation">(</span>new_m<span class="token punctuation">,</span> cnt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> F<span class="token punctuation">.</span>g<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> h1<span class="token punctuation">)</span><span class="token punctuation">;</span>                        OPEN<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>new_MS<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//设置向前查找</span>                        path<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>new_MS<span class="token punctuation">;</span>                        pre<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>F<span class="token punctuation">.</span>pos<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>算法采用c++的set容器<code>seen</code>维护已经看过的矩阵，采用priority_queue实现待展开矩阵状态<code>OPEN</code>的优先队列<br>在用第一个矩阵状态初始设置后，只要<code>OPEN</code>队列没有清空，就弹出其第一个矩阵状态（也即g+h最小的）作为<code>F</code>，如果<code>F</code>是终点则结束，否则展开<code>F</code>的所有子节点<br>在展开时需要对边界处理，因为并非所有ijs都是合法的。如果展开的节点是见过的则不展开，反之将它插入<code>seen</code>和<code>OPEN</code>中</p><p>为了最后能输出解，还需要在此时维护移动过程中产生的状态结构体数组<code>path</code>和每个状态的前一个状态的结构体编号<code>pre</code></p><h4 id="别人的技巧和经验"><a href="#别人的技巧和经验" class="headerlink" title="别人的技巧和经验"></a>别人的技巧和经验</h4><p>在尝试解决大于5*5的锁盘的时候，一开始碍于时间限制只能采用不可采纳的启发式。在这里总结了我身边同学的不可采纳的启发式：</p><ul><li>$\alpha*\lceil\frac{1的总数}{3}\rceil，\alpha&gt;1$<ul><li>据说调整$\alpha$的大小可以得到比较少的展开节点数</li></ul></li><li>$\sum_{i,j}\frac{dis(a_i, a_j)}{2*(1的总数)}$  即所有1的点之间的距离平均<ul><li>其中$a_i, a_j$是那些1的点的坐标，$dis(,)$取哈夫曼距离</li><li>用这个作为启发式，它的值是相当大了。但是它会给1的点分散的图很大的惩罚，以此驱使A*算法先考察1的点集中一些的图。这个想法是好的，因为两个点的距离更近的话，更有可能通过少数几次变化将它们同时解决</li><li>但是这个启发式的解释性很差：<ul><li>两个点之间的距离应该与<em>将它们同时解决的变化数</em>挂钩，而不应该与哈夫曼距离挂钩。当两个点的哈夫曼距离大到一定程度的时候，将它们解决的变化数达到6并且不会再变了 </li><li>多个点中的两两距离比较复杂，真正要考虑的距离可能只是它的一个部分</li></ul></li><li>所以这个启发式对输入很敏感，有的样例可以秒出答案，而有的却要展开很多很多节点</li></ul></li><li>$\sum_{i}w(a_i)$ 即对所有是1的点赋权重并相加<ul><li>其中$a_i$是那些1的点，$w()$是一个考虑该点附近情况的一个权重函数</li><li>理论上所有启发式都可以等价于这个形式，但是这个权重函数很难考虑出一个简单并且合适的</li></ul></li></ul><p>后来又得知了一个剪枝的方法，对于每个状态，只需要考虑<strong>包含锁盘上第一个1在内的12种翻转</strong>，这瞬间将每个状态的展开节点数降到很少，对于很大的锁盘也可以用可采纳的启发式解决了<br>而这个剪枝的想法也来源于对题目的观察：<strong>一个解的每个步骤都是可以任意调换顺序的</strong>，所以总能将它调换成翻转包括当前第一个1的顺序。由此可见对题目的分析还是很重要的</p><p>以下运行结果全部采用这种剪枝为基础</p><h3 id="运行结果总结"><a href="#运行结果总结" class="headerlink" title="运行结果总结"></a>运行结果总结</h3><p>最优解步数：</p><table><thead><tr><th>input0(5*5)</th><th>input1(3*3)</th><th>input2(4*4)</th><th>input3(5*5)</th><th>input4(5*5)</th><th>input5(5*5)</th><th>input6(9*9)</th><th>input7(9*9)</th><th>input8(10*10)</th><th>input9(12*12)</th></tr></thead><tbody><tr><td>5</td><td>4</td><td>5</td><td>7</td><td>7</td><td>7</td><td>11</td><td>14</td><td>16</td><td>23</td></tr></tbody></table><p>总展开节点数对比：</p><ul><li><p>$h_1$ （1的总数/3取上整）</p><table><thead><tr><th>input0(5*5)</th><th>input1(3*3)</th><th>input2(4*4)</th><th>input3(5*5)</th><th>input4(5*5)</th><th>input5(5*5)</th><th>input6(9*9)</th><th>input7(9*9)</th><th>input8(10*10)</th><th>input9(12*12)</th></tr></thead><tbody><tr><td>292</td><td>38</td><td>13</td><td>84</td><td>348</td><td>59</td><td>4398</td><td>3123</td><td>太大了</td><td>太大了</td></tr></tbody></table></li><li><p>$h_4$ （1的2*2覆盖总数）</p><table><thead><tr><th>input0(5*5)</th><th>input1(3*3)</th><th>input2(4*4)</th><th>input3(5*5)</th><th>input4(5*5)</th><th>input5(5*5)</th><th>input6(9*9)</th><th>input7(9*9)</th><th>input8(10*10)</th><th>input9(12*12)</th></tr></thead><tbody><tr><td>73</td><td>19</td><td>34</td><td>32</td><td>16</td><td>11</td><td>909</td><td>243</td><td>959</td><td>2714</td></tr></tbody></table></li><li><p>dijkstra</p><table><thead><tr><th>input0(5*5)</th><th>input1(3*3)</th><th>input2(4*4)</th><th>input3(5*5)</th><th>input4(5*5)</th><th>input5(5*5)</th><th>input6(9*9)</th><th>input7(9*9)</th><th>input8(10*10)</th><th>input9(12*12)</th></tr></thead><tbody><tr><td>2419</td><td>37</td><td>236</td><td>1318</td><td>1828</td><td>1548</td><td>太大了</td><td>太大了</td><td>太大了</td><td>太大了</td></tr></tbody></table></li></ul><p>显然就算最差的A*算法的性能也比dijkstra好，因为它毕竟是带有启发信息的</p><h2 id="exp1-2"><a href="#exp1-2" class="headerlink" title="exp1.2"></a>exp1.2</h2><h3 id="转化为约束满足问题"><a href="#转化为约束满足问题" class="headerlink" title="转化为约束满足问题"></a>转化为约束满足问题</h3><p>本题变量集合为每天的每个班次，值域集合为$\{0,1,…,N\}$</p><p>将每一天的每一班次视作一个可取$\{0,1,…,N\}$的变量，其中i表示它被指派了阿姨i，0表示它未被指派</p><p>定义几个约束：</p><ul><li>每天分为轮班次数个值班班次</li><li>每个班次都分给⼀个宿管阿姨</li><li>同⼀个宿管阿姨不能⼯作连续两个班次</li><li>每个宿管阿姨在整个排班周期中，应⾄少被分配到$\lfloor \frac{DS}{N}\rfloor$次</li></ul><p>那么第一个约束说明了有 D * S 个变量，第二个约束说明该约束满足问题的结束标志是每个变量都被指派了非0取值，这两者可以不纳入约束满足问题中约束的考虑<br>剩余两个约束定义为 $g_1$ 和 $g_2$ ，其中 $g_1$ 是 <strong>二元约束</strong> ，$g_2$是 <strong>全局约束</strong> </p><p>下面考虑怎么处理值班请求：<br>考虑到每一天的每一班次只能有一个赋值，所以 <strong>可以满足的请求数上界</strong> 是 $D * S$ </p><h4 id="将值班请求作为约束优化"><a href="#将值班请求作为约束优化" class="headerlink" title="将值班请求作为约束优化"></a>将值班请求作为约束优化</h4><p>值班请求也可以视为约束：<br>对每一天的每一个班次，每个阿姨都有一个对应的请求，对应一个约束</p><ul><li>如果阿姨的请求为1，而该班次的指派是她时，此约束不违背，此请求满足</li><li>如果阿姨的请求为1，而该班次的指派不是她时，此约束违背，此请求不满足</li><li>如果阿姨的请求为0，那么该班次的指派无论是不是她，都不视为违背，此请求不满足</li></ul><p>（考虑到请求为0的约束无论班次指派，所以可以不考虑它们）</p><p>而总共 $N * D * S$ 条值班请求中是1的部分，它们构成总请求约束集合 $Request$ ，每个约束都是 <strong>一元约束</strong><br>我们要最大化满足的请求，就是找到 $Request$ 集合的一个 <strong>最大的子集</strong> $R_1$ ，使得存在一个排班表，它满足 $R_1$ 中的所有约束以及上文的 $g_1$ 和 $g_2$ 约束，此时 $R_1$ 的大小即满足的请求数</p><h4 id="将值班请求作为值域优化"><a href="#将值班请求作为值域优化" class="headerlink" title="将值班请求作为值域优化"></a>将值班请求作为值域优化</h4><p>考虑对某一天的某一班次，有阿姨$\{n_{i_1},…n_{i_l}\}$都在请求，那么将它分配给$N - \{n_{i_1},…n_{i_l}\}$中的阿姨显然是浪费；将它分配给$\{n_{i_1},…n_{i_l}\}$中的某一个阿姨$n_k$，则$\{n_{i_1},…n_{i_l}\}-n_k$的请求不会满足，$n_k$的请求得到满足，这对于该班次来说，已经是最大的满足请求数了</p><p>所以可以用值班请求作为该班次的值域：<br>对于第$d$天的第$s$班次，有阿姨$\{n_{i_1}^{d,s},n_{i_2}^{d,s},…\}$都在请求，则设置该班次可被指派的值域为$\{0,n_{i_1}^{d,s},n_{i_2}^{d,s},…\}$（0表示尚未指派阿姨），在上面运行约束是$g_1$和$g_2$的CSP算法即可：</p><ul><li>如果有解，那么此时可以满足的请求数达到了上界$D*S$</li><li>如果没解，那么为了安排值班表，得扩充某些班次的值域，（由于我们关注的是优化值班请求，而值班请求依赖于班次，所以扩充时直接扩充到$N$即可）<ul><li>假设扩充了$k$个班次的所有情形CSP都无解，而扩充了$k+1$个班次的某个情形CSP有解，那么可满足的最大申请数$D*S-k-1$，该解就是最终的排班表</li></ul></li></ul><p>所以可以按照扩充的班次数运行<strong>广度优先搜索</strong></p><p>比较两种方法：</p><ul><li>它们都是将CSP算法作为一个验证手段，通过尝试不同的约束或者值域的CSP，找到一个使得可满足的申请数最大的CSP</li><li>将值班请求作为约束优化<ul><li>改变约束实现起来比较麻烦</li><li>对可满足的申请数<em>从小到大</em>搜索，不能保证搜到的第一个解是最优解</li></ul></li><li>将值班请求作为值域优化<ul><li>改变值域实现起来比较简单，可以使用同一套CSP算法模板</li><li>对可满足的申请数<em>从大到小</em>搜索，可以保证搜到的第一个解就是最优解</li></ul></li></ul><p>而且对于本次实验样例，因为1的分布比较密集，所有可以满足的请求数都接近上界$D * S$，综上选择 <strong>将值班请求作为值域优化</strong> </p><h3 id="CSP算法流程和实现"><a href="#CSP算法流程和实现" class="headerlink" title="CSP算法流程和实现"></a>CSP算法流程和实现</h3><p>维护一个状态结构体，里面包含在回溯搜索算法中当前状态每个班次的可用赋值和指派情况</p><pre class="line-numbers language-none"><code class="language-none">struct Status&#123;    &#x2F;&#x2F;可用赋值表：共D*S*(N+1)，available[d][s][n]为真表示d,s的n赋值可用，n&#x3D;0不表示东西    vector&lt; vector&lt; vector&lt;bool&gt; &gt; &gt; available;    &#x2F;&#x2F;指派表：共D行S列取值0~N，d行s列的值表示第d天第s班次的指派，0表示未指派    vector&lt; vector&lt;short&gt; &gt; assign;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">回溯搜索 back_track(state)输入：约束条件、初始状态 输出：完全有效赋值 assign 或失败if state.assign 是完全有效赋值 then    return state.assign通过MRV选择一个未赋值变量 X选择一个 X 的所有可能变量的随机排序 Dforeach var in D do    将指派 X 取 var 加入 assign，构造新状态 new_state    在 new_state 上运行前向检查，更新 new_state    if new_state.assign 是有效的 then        result &#x3D; back_track(new_state)        if result !&#x3D; failure then            return resultreturn failure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="何时使用全局约束"><a href="#何时使用全局约束" class="headerlink" title="何时使用全局约束"></a>何时使用全局约束</h4><p>回顾全局约束$g_2$：每个宿管阿姨在整个排班周期中，应⾄少被分配到$\lfloor \frac{DS}{N}\rfloor$次</p><p>但是在求解CSP问题时，对每个阿姨，她的排班是逐渐被确定的，即排班数是 <em>由少到多增长</em> ，如果所有阿姨都还没有分配很多排班，那么该怎么确定这个排班达到了$\lfloor \frac{DS}{N}\rfloor$次的下界呢？</p><p>一个简单的办法是把所有赋值都确定下来之后，再检查是否满足全局约束<br>这个函数被实现为<code>bool check_cons2(Status state)</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//递归终点</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check_finish</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check_cons2</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"finish!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        state<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bad end!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这个的性能非常差。我们放弃了<strong>早死早超生原则</strong>，而允许一些在赋值中途就能发现问题的赋值表走到最后</p><p>可以选择一个能够在赋值中途发现问题的方法：考察工作最多的几个阿姨是否让其它阿姨不能达到最低工作标准<br>这个函数被实现为<code>bool check_cons2_mid(Status state)</code>，实现起来更加复杂了，但是效率提升显著</p><p>还有一点：<strong>节点的赋值的展开顺序</strong>对性能也有很大影响：<br>譬如每个节点的可用赋值都是 1 ~ N ，并且每个节点的赋值展开都是按照 1 ~ N 的顺序尝试，那么递归运行<code>back_track</code>时，前几个节点会被依次赋值为<code>1，2，1，2，1，...</code>（因为它不违背约束$g_1$并且目前还没有违背$g_2$），但是这个赋值再往后有很大可能违背$g_2$，因为它用1，2太多了<br>那么有什么办法避免这种情况吗？答案是<strong>随机选择一个节点的赋值的展开顺序</strong>，即上面伪代码的<code>选择一个 X 的所有可能变量的随机排序 D</code>，这也是一种提前避免无效探索的剪枝</p><h4 id="前向检查"><a href="#前向检查" class="headerlink" title="前向检查"></a>前向检查</h4><p>约束$g_1$是二元约束，非常适合约束传播，而$g_2$则不适合，故不约束传播</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//将新状态的d，s，n赋值进行弧相容检查</span><span class="token comment">//只传播cons1</span><span class="token comment">//递归进行，直到不能约束传播为止</span><span class="token keyword">void</span> <span class="token function">forward_check</span><span class="token punctuation">(</span><span class="token keyword">short</span> d<span class="token punctuation">,</span> <span class="token keyword">short</span> s<span class="token punctuation">,</span> <span class="token keyword">short</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//cons1中弧相容只涉及前后两个节点，注意跨天情况和边界情况（这里考虑s>=3）</span>    <span class="token keyword">short</span> d1<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> d2<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>d <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        available<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">short</span> only_n1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">count_available</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> only_n1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> assign<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            assign<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> only_n1<span class="token punctuation">;</span>            <span class="token function">forward_check</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> only_n1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>d <span class="token operator">==</span> D<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> s <span class="token operator">==</span> S<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        available<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">short</span> only_n1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">count_available</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> only_n1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> assign<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            assign<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> only_n1<span class="token punctuation">;</span>            <span class="token function">forward_check</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> only_n1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        d1 <span class="token operator">=</span> d<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        s1 <span class="token operator">=</span> S<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        d2 <span class="token operator">=</span> d<span class="token punctuation">;</span>        s2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> S<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        d1 <span class="token operator">=</span> d<span class="token punctuation">;</span>        s1 <span class="token operator">=</span> s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        d2 <span class="token operator">=</span> d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        s2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        d1 <span class="token operator">=</span> d<span class="token punctuation">;</span>        s1 <span class="token operator">=</span> s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        d2 <span class="token operator">=</span> d<span class="token punctuation">;</span>        s2 <span class="token operator">=</span> s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//注销两个节点中n的可用性</span>    available<span class="token punctuation">[</span>d1<span class="token punctuation">]</span><span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    available<span class="token punctuation">[</span>d2<span class="token punctuation">]</span><span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">//如果某个节点只有一个可用且未赋值，那么更新赋值</span>    <span class="token keyword">short</span> only_n1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">short</span> only_n2 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">count_available</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> only_n1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> assign<span class="token punctuation">[</span>d1<span class="token punctuation">]</span><span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        assign<span class="token punctuation">[</span>d1<span class="token punctuation">]</span><span class="token punctuation">[</span>s1<span class="token punctuation">]</span> <span class="token operator">=</span> only_n1<span class="token punctuation">;</span>        <span class="token function">forward_check</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> only_n1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">count_available</span><span class="token punctuation">(</span>d2<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> only_n2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> assign<span class="token punctuation">[</span>d2<span class="token punctuation">]</span><span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        assign<span class="token punctuation">[</span>d2<span class="token punctuation">]</span><span class="token punctuation">[</span>s2<span class="token punctuation">]</span> <span class="token operator">=</span> only_n2<span class="token punctuation">;</span>        <span class="token function">forward_check</span><span class="token punctuation">(</span>d2<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> only_n2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在不考虑边界条件和跨天情况时，要将d天s班次的n赋值约束传播到它前后两个班次，即注销掉<code>available</code>中它们的可用性<br>如果注销掉可用性时它刚好只有一个赋值可用，那么就可以用这个来赋值，并递归地触发下一个约束传播</p><h4 id="最小剩余值启发式"><a href="#最小剩余值启发式" class="headerlink" title="最小剩余值启发式"></a>最小剩余值启发式</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//MRV启发式，返回目前的可用赋值最少的未赋值节点d，s</span><span class="token keyword">void</span> <span class="token function">MRV_find</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token operator">&amp;</span>d_find<span class="token punctuation">,</span> <span class="token keyword">short</span> <span class="token operator">&amp;</span>s_find<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> count_min <span class="token operator">=</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">short</span> i_find<span class="token punctuation">,</span> j_find<span class="token punctuation">;</span>    <span class="token keyword">short</span> nouse<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">short</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>D<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">short</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>S<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//遍历assign表找未指派的节点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>assign<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">count_available</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> nouse<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> count_min<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    count_min <span class="token operator">=</span> count<span class="token punctuation">;</span>                    i_find <span class="token operator">=</span> i<span class="token punctuation">;</span>                    j_find <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    d_find <span class="token operator">=</span> i_find<span class="token punctuation">;</span>    s_find <span class="token operator">=</span> j_find<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依据当前<code>assign</code>表寻找未赋值的节点，并统计它们的可用赋值数，最终返回可用赋值最少的节点</p><h4 id="将值班请求作为值域优化-1"><a href="#将值班请求作为值域优化-1" class="headerlink" title="将值班请求作为值域优化"></a>将值班请求作为值域优化</h4><p>这里涉及到两个部分：</p><ul><li>用值班请求初始化CSP中每个节点的值域</li><li>在当前CSP无解时拓展哪个节点的值域</li></ul><p>实现了类<code>Request</code>，其中<code>r</code>记录了各个值班请求</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//请求表 N*D行，每行S个元素表示请求</span><span class="token keyword">struct</span> <span class="token class-name">Request</span><span class="token punctuation">&#123;</span>     vector<span class="token operator">&lt;</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">></span> r<span class="token punctuation">;</span>    <span class="token function">Request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//设置状态S的可用赋值</span>    <span class="token keyword">void</span> <span class="token function">set_available</span><span class="token punctuation">(</span>Status <span class="token operator">&amp;</span>State<span class="token punctuation">)</span>    <span class="token comment">//拓展状态S的可用赋值</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Request Req_in<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在读入文件时初始化<code>Req_in</code>，然后调用<code>set_available</code>初始化CSP中每个节点的值域</p><p>拓展节点值域时，因为我们希望拓展后尽快找到有解的CSP，所以优先拓展值域最小的节点，这部分也可以复用MRV启发式的代码</p><h3 id="运行结果（以input0为例）"><a href="#运行结果（以input0为例）" class="headerlink" title="运行结果（以input0为例）"></a>运行结果（以input0为例）</h3><p>有意思的是，input0是唯一一个可满足的请求数达不到上限 $D * S$ 的样例，所以按照 <em>用请求初始化值域</em> 的方法来做，会发现第4天的第0个班次没有值域<br>此时需要拓展该班次的值域为1 ~ N并重新运行即可<br>此时有解：</p><pre class="line-numbers language-none"><code class="language-none">D0: 1 2 1D1: 2 3 1D2: 3 2 1D3: 3 1 2D4: 3 2 1D5: 3 2 3D6: 1 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照前面论证的，在每个节点的值域都不拓展的时候无解，而拓展了一个节点的值域就有解的，说明其最大的可满足请求数 $D * S-1$ </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>新的开始</title>
      <link href="/2023/08/04/new-start/"/>
      <url>/2023/08/04/new-start/</url>
      
        <content type="html"><![CDATA[<p>一下鸽了一年半</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>在博客根目录下打开 git bash ，以下操作都在该终端：</p><ul><li><p>新建博客</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new post <span class="token string">"article title"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>source\_posts</code> 中会生成以 article title 为名的文件夹，以及同名的 markdown 文件，对应资源文件位置和文章</p></li><li><p>生成静态网页</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>本地预览</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后可以在 <a href="http://localhost:4000/">http://localhost:4000/</a> 中打开</p></li><li><p>上传 github</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><h3 id="图片测试"><a href="#图片测试" class="headerlink" title="图片测试"></a>图片测试</h3><img src="test1.jpg" alt="jpg test"  /><img src="test2.gif" alt="gif test"  /><img src="https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png" alt="web test" /><h3 id="音频测试"><a href="#音频测试" class="headerlink" title="音频测试"></a>音频测试</h3><div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=419594177&auto=0&height=66"></iframe></div><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><p><a href="ai homework.pdf" class='download' download="download">ai homework.pdf</a></p><h3 id="公式测试"><a href="#公式测试" class="headerlink" title="公式测试"></a>公式测试</h3><p>用<code>$ $</code>包裹的公式是靠左对齐，如 $\alpha + \beta$，用<code>$$ $$</code>包裹的是居中对齐</p><p>$$<br>\Bigg(\bigg(\Big(\big((x)\big)\Big)\bigg)\Bigg)<br>$$</p><p>$$<br>\prod_{n=1}^5\sum_{i = 1}^n\frac{1}{i^2}<br>$$</p><p>$$<br>y=<br>\begin{cases}<br>-x, \quad x\leq 0\\<br>x,\quad x&gt;0<br>\end {cases}<br>\tag{1}<br>$$</p><p>$a=\begin{bmatrix}1\\2\\3\end{bmatrix}$<br>$a=\left( \begin{matrix}1\\2\\3\end{matrix} \right)$</p><p>$$<br>\begin {bmatrix}<br>1 &amp; 2 &amp; 3 \\<br>2 &amp; 4 &amp; 6 \\<br>3 &amp; 6 &amp; 9<br>\end {bmatrix}<br>\tag{2}<br>$$</p><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><p>识别 cpp 而不识别 c++<br>识别 python 而不识别 py</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> os <span class="token keyword">import</span> path<span class="token keyword">def</span> <span class="token function">check_for_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Does file exist:"</span><span class="token punctuation">,</span> path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">"data.csv"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>    check_for_file<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修复问题"><a href="#修复问题" class="headerlink" title="修复问题"></a>修复问题</h2><h3 id="资源失效"><a href="#资源失效" class="headerlink" title="资源失效"></a>资源失效</h3><p>发现无论是在 github.io 还是在本地，首页加载速度都很慢<br><img src="error1.png" alt="console error"  /><br>在 console 报错载入资源失败<br>定位到</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/typed.js@2.0.11<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">     <span class="token keyword">var</span> typed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Typed</span><span class="token punctuation">(</span><span class="token string">"#subtitle"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">strings</span><span class="token operator">:</span> <span class="token punctuation">[</span>                             <span class="token string">"Calculating Calculating Calculating..."</span><span class="token punctuation">,</span>                            <span class="token string">"Calculating Calculating Calculating..."</span><span class="token punctuation">,</span>                            <span class="token string">"Calculation complete"</span><span class="token punctuation">,</span>                    <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token literal-property property">startDelay</span><span class="token operator">:</span> <span class="token number">300</span><span class="token punctuation">,</span>        <span class="token literal-property property">typeSpeed</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>        <span class="token literal-property property">loop</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token literal-property property">backSpeed</span><span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">,</span>        <span class="token literal-property property">showCursor</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是一个显示动态打字效果的库，现在无法使用<br>在 <a href="https://mattboldt.github.io/typed.js/docs/">https://mattboldt.github.io/typed.js/docs/</a> 中发现 cdn 地址变成了</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/typed.js@2.0.16/dist/typed.umd.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>themes\hexo-theme-matery\layout\_partial\bg-cover-content.ejs</code> 中替换它了之后，资源加载就正常了，不需要再在各个 <code>index.html</code> 中一一替换</p><h3 id="数学公式显示"><a href="#数学公式显示" class="headerlink" title="数学公式显示"></a>数学公式显示</h3><ul><li><p>开启 mathjax<br>使用 mathjax 渲染Tex/LaTex数学公式</p><p>在 <code>themes\hexo-theme-matery\layout\post.ejs</code> 中添加</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并在 theme 中（如 <code>themes\hexo-theme-matery\_config.yml</code>）开启 mathjax 功能，并在每篇 post 开头开启 mathjax 功能</p></li><li><p>避免冲突<br>为了不和代码高亮冲突，不安装 <code>kramed</code> 插件，直接使用原本自带的 <code>marked</code> 插件<br>由于 markdown 语法与 mathjax 语法存在冲突<br>（比如 markdown 中用 <code>_</code> 表示_斜体_，但是 Latex 中表示脚标，Hexo渲染 markdown 时会把 <code>_</code> 强制渲染成 <code>&lt;em&gt;</code> ；<br>比如 markdown 中用 <code>\\</code> 表示单斜杠\\，但是 Latex 中表示换行）</p></li><li><p>回退版本<br>所以还需要修改源文件，但是为了和网上过时的教程同步，先将 <code>hexo-renderer-marked</code> 退回2018年的1.0.0：<br>在 blog 文件夹：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> uninstall hexo-renderer-marked<span class="token function">npm</span> <span class="token function">install</span> hexo-renderer-marked@1.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改规则<br>在 <code>node_modules\marked\lib\marked.js</code> 中第539行改成</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">escape: /^\\([!"#$&amp;'()*+,\-./:;&lt;=>?@\[\]^_`|~])/,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第564行改成</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">inline._escapes = /\\([!"#$&amp;'()*+,\-./:;&lt;=>?@\[\]^_`|~])/g;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样 <code>marked</code> 就可以正确翻译 markdown 中的 <code>\\</code> 为 <code>\\</code> 而非 <code>\</code> ，从而 mathjax 得以正确按照 Latex 语法渲染公式</p><p>同理在 <code>node_modules\marked\lib\marked.js</code> 中第606行改成</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不知道第552行要不要修改，这样就可以正确翻译 <code>_</code></p></li><li><p>特殊注意<br>如果公式中有很多括号和斜杠连续出现，最好用空格把它们分割开来<br>参考<br><a href="https://zhuanlan.zhihu.com/p/476601594?utm_id=0">https://zhuanlan.zhihu.com/p/476601594?utm_id=0</a><br><a href="https://www.jianshu.com/p/16b7ef2653de">https://www.jianshu.com/p/16b7ef2653de</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> how-to系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动健康打卡</title>
      <link href="/2022/02/12/auto-report/"/>
      <url>/2022/02/12/auto-report/</url>
      
        <content type="html"><![CDATA[<h1 id="自动健康打卡"><a href="#自动健康打卡" class="headerlink" title="自动健康打卡"></a>自动健康打卡</h1><h2 id="先跑起来"><a href="#先跑起来" class="headerlink" title="先跑起来"></a>先跑起来</h2><p>基于Github仓库：<a href="https://github.com/xbb1973/USTC-ncov-AutoReport">https://github.com/xbb1973/USTC-ncov-AutoReport</a></p><p>fork别人的仓库然后改改配置文件，然后通过Github的actions功能实现定时打卡<br>十分钟完事了<br>结果workflows在登录那一步就失败了：</p><img src="1.png" alt="login failed"><p>原来这个版本不能识别验证码，而它的workflows是在github提供的ubuntu虚拟机上跑的，在校外网络环境登录时必须填写验证码</p><p>可以使用自己的运行器跑，正好学校vlab提供了ubuntu虚拟机，并且是校内网络环境，不需要填验证码…………</p><p>但是为什么不自己在虚拟机上写一个python自动打卡程序呢？或者找个办法识别验证码</p><p>找到了另一个人在原先版本上做出的改进：<a href="https://github.com/Kobe972/USTC-ncov-AutoReport">https://github.com/Kobe972/USTC-ncov-AutoReport</a> 因为网站的验证码比较简单，所以直接调用pytesseract库，就能识别验证码了</p><p>虽然能登录进去了，但是不能成功打卡。如图：检验上次打卡时间可知</p><img src="3.jpg" alt="report failed"><p>最后发现是data格式问题，每次健康上报时提交的信息参数就是data.json，但是原版本和现在版本的内容并不一样</p><p>原版本data.json<br><img src="4.jpg" alt="pre data"><br>按照这个版本上报并不能成功</p><p>在浏览器里点击确认上报，通过F12开发者工具抓包，点击抓到的 daliy_report 请求，在 Headers 下面找到 Form Data<br><img src="5.jpg" alt="post data"><br>按照这个格式修改data.json就可以了<br><img src="6.jpg" alt="success"></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>作为刚学python的人，通过这个案例来学习再好不过了吧<br>（注：以下内容与源文件并不一定一致）<br>python的强大之处在于有很多厉害的库，可以让我们轻松地实现复杂的功能，下面将介绍一些用到的库：</p><h3 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h3><p><a href="https://docs.python-requests.org/zh_CN/latest/index.html">https://docs.python-requests.org/zh_CN/latest/index.html</a></p><p>它是很易用的HTTP库，可以简便地完成HTTP请求</p><h4 id="实现HTTP请求："><a href="#实现HTTP请求：" class="headerlink" title="实现HTTP请求："></a>实现HTTP请求：</h4><p><strong>get</strong>： 主要用于向指定的URL请求资源（资源文件或是数据均可）， 可以带参数也可以不带参数， 带参数时，参数是明文传递，你可以在浏览器的地址栏中看到参数名及参数值，get安全性不高，所以常用于安全性要求低的场合， 比如登录后请求数据。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://api.github.com/events'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就获得了github的公共时间线，从这个名为 r 的 Response 对象中可以获取所有我们想要的信息</p><p>比如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">r<span class="token punctuation">.</span>text<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会以文本的形式读取服务器响应的内容<br>Requests 会自动解码来自服务器的内容。请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests 会使用其推测的文本编码<br>可以使用<code>r.encoding</code>来查看或修改当前编码模式</p><p>又如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> io <span class="token keyword">import</span> BytesIOtext<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://passport.ustc.edu.cn/validatecode.jsp?type=login'</span><span class="token punctuation">,</span>stream<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contentimage<span class="token operator">=</span>Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>BytesIO<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>.content 会以二进制形式读取服务器响应的内容<br>然后可以调用PIL库的Image和io库的BytesIO，以图片形式打开这个二进制串，获取登录的验证码图片</p><p><strong>post</strong>：主要是向指定的URL提交数据, 通常用于表单发送，psot所传递的数据或参数不是已明文形式存在的，而是封装后的，因此相对安全系数高，像注册、登录、提交表单都是用该方法实现的。 </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">payload <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token string">'model'</span><span class="token punctuation">:</span> <span class="token string">'uplogin.jsp'</span><span class="token punctuation">,</span>        <span class="token string">'service'</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>service<span class="token punctuation">,</span>        <span class="token string">'warn'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>        <span class="token string">'showCode'</span><span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>        <span class="token string">'username'</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>stuid<span class="token punctuation">,</span>        <span class="token string">'password'</span><span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>password<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">'button'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>        <span class="token string">'CAS_LT'</span><span class="token punctuation">:</span>CAS_LT<span class="token punctuation">,</span>        <span class="token string">'LT'</span><span class="token punctuation">:</span>LT        <span class="token punctuation">&#125;</span>r<span class="token operator">=</span>requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'https://passport.ustc.edu.cn/login'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>payload<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上就将表单payload的内容发送给了ustc登录界面</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>            <span class="token string">'authority'</span><span class="token punctuation">:</span> <span class="token string">'weixine.ustc.edu.cn'</span><span class="token punctuation">,</span>            <span class="token string">'origin'</span><span class="token punctuation">:</span> <span class="token string">'https://weixine.ustc.edu.cn'</span><span class="token punctuation">,</span>            <span class="token string">'upgrade-insecure-requests'</span><span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>            <span class="token string">'content-type'</span><span class="token punctuation">:</span> <span class="token string">'application/x-www-form-urlencoded'</span><span class="token punctuation">,</span>            <span class="token string">'user-agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.164 Safari/537.36'</span><span class="token punctuation">,</span>            <span class="token string">'accept'</span><span class="token punctuation">:</span> <span class="token string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'</span><span class="token punctuation">,</span>            <span class="token string">'referer'</span><span class="token punctuation">:</span> <span class="token string">'https://weixine.ustc.edu.cn/2020/'</span><span class="token punctuation">,</span>            <span class="token string">'accept-language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.9'</span><span class="token punctuation">,</span>            <span class="token string">'Connection'</span><span class="token punctuation">:</span> <span class="token string">'close'</span><span class="token punctuation">,</span>            <span class="token string">'cookie'</span><span class="token punctuation">:</span> <span class="token string">"PHPSESSID="</span> <span class="token operator">+</span> login<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"PHPSESSID"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">";XSRF-TOKEN="</span> <span class="token operator">+</span> login<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"XSRF-TOKEN"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">";laravel_session="</span><span class="token operator">+</span>login<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"laravel_session"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token punctuation">&#125;</span>url <span class="token operator">=</span> <span class="token string">"https://weixine.ustc.edu.cn/2020/daliy_report"</span>resp<span class="token operator">=</span>requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以显式地设置url和headers<br>这里通过自己写headers来伪装成浏览器访问，避开反爬虫检测</p><p>此外HTTP还要其它请求，在此按住不表</p><h4 id="会话对象"><a href="#会话对象" class="headerlink" title="会话对象"></a>会话对象</h4><p>服务器通过session来区分不同的用户请求，requests.Session对象就是模拟这种操作的，可以跨请求保持一些参数————比如不需要每次切换页面之后都要重新登录。requests.Session对象也可以用上面的那些方法</p><h3 id="BeautifulSoup库"><a href="#BeautifulSoup库" class="headerlink" title="BeautifulSoup库"></a>BeautifulSoup库</h3><p><a href="https://www.crummy.com/software/BeautifulSoup/">https://www.crummy.com/software/BeautifulSoup/</a></p><p>Beautiful Soup 提供一些简单的、python 式的函数用来处理导航、搜索、修改分析树等功能。在爬虫中主要用来提取出 HTML 标签中的内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> login<span class="token punctuation">.</span>result<span class="token punctuation">.</span>text        data <span class="token operator">=</span> data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">,</span><span class="token string">'ignore'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span><span class="token string">'ignore'</span><span class="token punctuation">)</span>        soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'html.parser'</span><span class="token punctuation">)</span>        token <span class="token operator">=</span> soup<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"_token"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'value'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Beautiful Soup 将复杂 HTML 文档转换成一个复杂的树形结构，每个节点都是 Python 对象，所有对象可以归纳为 4 种:</p><ul><li>Tag</li><li>NavigableString</li><li>BeautifulSoup</li><li>Comment</li></ul><p>详细用法可以看这篇：<br><a href="https://cuiqingcai.com/1319.html">https://cuiqingcai.com/1319.html</a></p><h2 id="再加一个功能"><a href="#再加一个功能" class="headerlink" title="再加一个功能"></a>再加一个功能</h2><p>实际上自动健康打卡在学校并不是刚需（几个月不打卡都不会有事），但是自动出校报备却是刚需：每过一周就要报备出校一次，否则一卡通会无法解锁门禁系统。这个功能和前面的健康打卡很像：</p><h3 id="按下按钮？"><a href="#按下按钮？" class="headerlink" title="按下按钮？"></a>按下按钮？</h3><img src="8.jpg" alt="html"><p>Requests库通过post模拟点击“提交申请”，但是网站有一个“本人承诺”的 <code>checkbox</code> 如果不点击它，则不能点击“提交申请”。它们之间的逻辑是以脚本的形式写在html文件里面的：</p><img src="9.jpg" alt="script"><p>会不会非得按下那个 <code>checkbox</code> 之后，才能成功post呢？</p><p>结论是，<strong>不用</strong>，只要知道往哪个url里面post就行了</p><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">start_date <span class="token operator">=</span> date<span class="token punctuation">.</span>today<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> start_date<span class="token punctuation">.</span>weekday<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            end_date <span class="token operator">=</span> start_date <span class="token operator">+</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">)</span>            start_date <span class="token operator">=</span> start_date<span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>            end_date <span class="token operator">=</span> end_date<span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>                       data2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>                <span class="token string">"_token"</span><span class="token punctuation">:</span> token2<span class="token punctuation">,</span>                <span class="token string">"start_date"</span><span class="token punctuation">:</span> start_date<span class="token punctuation">,</span>                <span class="token string">"end_date"</span><span class="token punctuation">:</span> end_date            <span class="token punctuation">&#125;</span>            headers2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">&#125;</span>            url2 <span class="token operator">=</span> <span class="token string">"https://weixine.ustc.edu.cn/2020/apply/daliy/post"</span>            resp2 <span class="token operator">=</span> login<span class="token punctuation">.</span>session<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url2<span class="token punctuation">,</span> data<span class="token operator">=</span>data2<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用date库查看当日日期，如果是周三，就在健康打卡之后进行出校报备（因为出校报备一周一次就够了）</p><img src="7.jpg" alt="post data"><p>依照抓到的包的形式自己写一个 <code>data2</code> post上去，post的目标 <code>url2</code> 也是在网页html中可以找到</p><p>但是这样并不能成功报备，只能合理怀疑 <code>token</code> 有问题了，我之前认为它和健康打卡post的 <code>token</code> 一样，再次用BeautifulSoup找出当前的 <code>token</code> ，结果发现和之前一样</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> login<span class="token punctuation">.</span>session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://weixine.ustc.edu.cn/2020/apply/daliy'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text                   data <span class="token operator">=</span> data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">,</span> <span class="token string">'ignore'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span> <span class="token string">'ignore'</span><span class="token punctuation">)</span>                   soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'html.parser'</span><span class="token punctuation">)</span>                   token <span class="token operator">=</span> soup<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"_token"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'value'</span><span class="token punctuation">]</span>                   token2 <span class="token operator">=</span> token<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么就是headers的问题了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">headers2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>               <span class="token string">'authority'</span><span class="token punctuation">:</span> <span class="token string">'weixine.ustc.edu.cn'</span><span class="token punctuation">,</span>               <span class="token string">'upgrade-insecure-requests'</span><span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>               <span class="token string">'content-type'</span><span class="token punctuation">:</span> <span class="token string">'text/html; charset=UTF-8'</span><span class="token punctuation">,</span>               <span class="token string">'user-agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.164 Safari/537.36'</span><span class="token punctuation">,</span>               <span class="token string">'accept'</span><span class="token punctuation">:</span> <span class="token string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'</span><span class="token punctuation">,</span>               <span class="token string">'referer'</span><span class="token punctuation">:</span> <span class="token string">'https://weixine.ustc.edu.cn/2020/home'</span><span class="token punctuation">,</span>               <span class="token string">'accept-language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.9'</span><span class="token punctuation">,</span>               <span class="token string">'cookie'</span><span class="token punctuation">:</span> <span class="token string">"PHPSESSID="</span> <span class="token operator">+</span> login<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"PHPSESSID"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">";XSRF-TOKEN="</span> <span class="token operator">+</span> login<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"XSRF-TOKEN"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">";laravel_session="</span> <span class="token operator">+</span> login<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"laravel_session"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上headers写多少，写什么内容都不是必须的，本着言多必失的原则，将它缩短一点，只保留可能被用来反爬虫检测的部分：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">headers2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>                <span class="token string">'user-agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.164 Safari/537.36'</span><span class="token punctuation">,</span>                <span class="token string">'cookie'</span><span class="token punctuation">:</span> <span class="token string">"PHPSESSID="</span> <span class="token operator">+</span> login<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"PHPSESSID"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">";XSRF-TOKEN="</span> <span class="token operator">+</span> login<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"XSRF-TOKEN"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">";laravel_session="</span> <span class="token operator">+</span> login<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"laravel_session"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果就成功了！</strong><br>说明还是headers的某条参数的问题</p><h3 id="检测是否成功"><a href="#检测是否成功" class="headerlink" title="检测是否成功"></a>检测是否成功</h3><p>打卡之后应该检测是否成功，就是到 <a href="https://weixine.ustc.edu.cn/2020/apply_total">https://weixine.ustc.edu.cn/2020/apply_total</a> 页面中查看最后一次报备时间：</p><img src="10.jpg" alt="check it"><p>具体来说，要用Requests库get网页html文件，再用BeautifulSoup库解析文件，并且用re库进行正则表达式匹配</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> login<span class="token punctuation">.</span>session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://weixine.ustc.edu.cn/2020/apply_total"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textsoup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'html.parser'</span><span class="token punctuation">)</span>context <span class="token operator">=</span> soup<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"table"</span><span class="token punctuation">)</span>pattern <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">"202[0-9]-[0-9]&#123;2&#125;-[0-9]&#123;2&#125; [0-9]&#123;2&#125;:[0-9]&#123;2&#125;:[0-9]&#123;2&#125;"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面就在BeautifulSoup找到的table表格中寻找满足pattern条件的<strong>第一个字符串</strong>，那就是最近一次打卡时间，并与现在时间作差值，如果在最近（两分钟内）申报过，那么就视为成功</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">flag <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">if</span> pattern<span class="token punctuation">.</span>search<span class="token punctuation">(</span>token<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                date1 <span class="token operator">=</span> pattern<span class="token punctuation">.</span>search<span class="token punctuation">(</span>token<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Latest apply: "</span> <span class="token operator">+</span> date1<span class="token punctuation">)</span>                date1 <span class="token operator">=</span> date1 <span class="token operator">+</span> <span class="token string">" +0800"</span>                reporttime <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span>date1<span class="token punctuation">,</span> <span class="token string">"%Y-%m-%d %H:%M:%S %z"</span><span class="token punctuation">)</span>                timenow <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span>pytz<span class="token punctuation">.</span>timezone<span class="token punctuation">(</span><span class="token string">'Asia/Shanghai'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                delta <span class="token operator">=</span> timenow <span class="token operator">-</span> reporttime                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; second(s) before."</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>delta<span class="token punctuation">.</span>seconds<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> delta<span class="token punctuation">.</span>seconds <span class="token operator">&lt;</span> <span class="token number">120</span><span class="token punctuation">:</span>                        flag <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Report FAILED!"</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Report SUCCESSFUL!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>至此，自动健康打卡和出门申报功能就齐全了</strong></p><h3 id="那么，在哪里可以用到呢？"><a href="#那么，在哪里可以用到呢？" class="headerlink" title="那么，在哪里可以用到呢？"></a>那么，在哪里可以用到呢？</h3><p>实际上自动健康打卡是一个灰色地带，能不能用还是个问题<br>源码发布在 <a href="https://github.com/Baorunhui/USTC-ncov-AutoReport">https://github.com/Baorunhui/USTC-ncov-AutoReport</a><br>再次感谢我借鉴学习的<strong>xbb1973</strong>和<strong>Kobe972</strong>的代码</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>登录网站的验证往往是个大问题，本次健康打卡平台的验证码实在是容易识别，不过别的平台就不是这样了</p><p>参考 <a href="https://blog.csdn.net/weizhen11/article/details/102509230/">https://blog.csdn.net/weizhen11/article/details/102509230/</a> 使用pyppeteer库可以实现更加强大的功能 </p><ul><li><p>一：淘宝验证码 拖动滑块</p><ul><li><p>(1) 淘宝的验证码验证模块会检测浏览器环境，要注入JS ；</p></li><li><p>(2) 尽可能模拟用户操作，随机数减慢 Pyppeteer 的执行速度</p></li></ul></li><li><p>二：12306验证码</p><ul><li>对接打码平台是比较不错的选择；原理就是把验证码图片以字节的方式发给他们，返回一个字符串，例如：183,68|193,161;<br>比如超级鹰打码平台API:chaojiying.py</li></ul></li></ul><p>不过像打码平台这个是不是灰色产业，我就不清楚了</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github使用指南</title>
      <link href="/2022/02/08/how-to-use-github/"/>
      <url>/2022/02/08/how-to-use-github/</url>
      
        <content type="html"><![CDATA[<h1 id="Github使用指南"><a href="#Github使用指南" class="headerlink" title="Github使用指南"></a>Github使用指南</h1><p>本文希望以简洁易懂的形式介绍Github的各种使用方法和功能</p><p>详细请阅读官方文档</p><h2 id="一、如何稳定地上Github"><a href="#一、如何稳定地上Github" class="headerlink" title="一、如何稳定地上Github"></a>一、如何稳定地上Github</h2><h2 id="二、术语"><a href="#二、术语" class="headerlink" title="二、术语"></a>二、术语</h2><p><strong>Repository</strong>：仓库，存放项目的地方</p><p><strong>Issues</strong>：问题</p><p><strong>Star</strong>：点赞</p><p><strong>Fork</strong>：拉分支，在一个项目的基础上修改时，通过Fork这个项目，复制一个完成相同且独立的项目到我们的 GitHub 账号之中。之后就可以在自己复制的项目中修改了。</p><p><strong>Pull Request</strong>：提交请求，Fork完一个项目并修改后，可以对原项目的拥有者提出一个Pull请求，审核完毕之后，修改就会合并到原项目中</p><p><strong>Merge</strong>：合并，即上述的合并</p><p><strong>Watch</strong>：观察，Watch了一个项目之后，能在第一时候收到该项目的更新通知。</p><h2 id="三、Git常用使用命令"><a href="#三、Git常用使用命令" class="headerlink" title="三、Git常用使用命令"></a>三、Git常用使用命令</h2><p>Github是基于版本控制系统Git的，本文不介绍怎么装<br>（本文基于git version 2.34.1.windows.1，详情请查看官方使用文档）</p><p>打开一个文件夹，右键Git Bash Here，可以打开Git Bash命令行窗口，下面所有操作都是在此窗口进行：</p><p>首先应该做的是让Git认识你，输入：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"Your Name Comes Here"</span><span class="token function">git</span> config --global user.email you@yourdomain.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>git init</strong>：初始化Git仓库，将当前文件夹变成空的仓库（repository）</p><p><strong>git status</strong>：查看仓库状态</p><p><strong>git add file1 file2 file3</strong>：将位于此文件夹的若干文件加入临时缓冲区中</p><p><strong>git commit -m “some_information”</strong>：将临时缓冲区的文件提交到仓库，并且记录一则信息</p><p><strong>git commit -a</strong>：跳过临时缓冲区，直接将原有文件的所有改动提交到仓库，<em>注意：这不会提交新文件</em></p><p><strong>git log</strong>：打印提交日志</p><p><strong>git branch</strong>：查看仓库分支情况，在分支名前通过*表明当前位置</p><p><strong>git branch newBranchName</strong>：建立新分支newBranchName</p><p><strong>git checkout anotherBranchName</strong>：切换到anotherBranchName分支</p><p><strong>git checkout -b newBranchName</strong>：建立新分支newBranchName的同时切换到该分支</p><p><strong>git merge anotherBranchName</strong>：将anotherBranchName分支与当前所在分支合并</p><p><strong>git branch -d anotherBranchName &amp; git branch -D anotherBranchName</strong>：将anotherBranchName分支删除，如果它未与master分支合并，则前者指令无法删除，需要后者指令强制删除</p><p><strong>git help -a</strong>：git 指令简短说明</p><h2 id="四、通过Git访问Github"><a href="#四、通过Git访问Github" class="headerlink" title="四、通过Git访问Github"></a>四、通过Git访问Github</h2><p>假设已经完成ssh绑定，这里仅介绍用法</p><p>在Github网站的仓库页面中选择code，复制如下内容（就是当前网址加后缀.git）<br><img src="1.jpg" alt="code clone"  /></p><p><strong>git clone <a href="https://github.com/userName/repoName.git">https://github.com/userName/repoName.git</a></strong>：<br>将userName的repoName复制到本地（位置即是当前文件夹），此后就可以在本地进行修改</p><p><strong>git remote add whateverName <a href="https://github.com/userName/repoName.git">https://github.com/userName/repoName.git</a></strong>：<br>在本地init一个新仓库之后，将其关联一个命名为whateverName（一般命名为origin，<em>注意：这个和repoName无关</em>）的远程仓库，它的地址是<a href="https://github.com/userName/repoName.git">https://github.com/userName/repoName.git</a></p><p><strong>git remote -v</strong>:<br>查看已关联的远程仓库情况</p><p><strong>git pull whateverName master</strong>：同步whateverName远程仓库和本地仓库的master分支</p><p><strong>git push whateverName master</strong>：将本地仓库提交到你的whateverName远程仓库master分支</p><h2 id="五、Gitee下载"><a href="#五、Gitee下载" class="headerlink" title="五、Gitee下载"></a>五、Gitee下载</h2><p>由于Github下载速度感人，可以通过国内的代码托管平台Gitee导入Github平台的仓库<br><a href="https://gitee.com/projects/import/url">https://gitee.com/projects/import/url</a><br>然后再pull或者clone<br><img src="2.jpg" alt="gitee import"  /></p><p>也可以用Git访问Gitee，和通过Git访问Github同理，只是需要<strong>git remote add</strong>一个新的远程仓库，并且在push和pull时指定那个仓库即可</p><h2 id="六、Actions"><a href="#六、Actions" class="headerlink" title="六、Actions"></a>六、Actions</h2><p>参照<a href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a><br>GitHub 允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用，这就是GitHub Actions<br>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录，可以通过它配置任务触发条件、虚拟机环境、运行步骤……</p><h2 id="通过Github写博客"><a href="#通过Github写博客" class="headerlink" title="通过Github写博客"></a>通过Github写博客</h2><p>Github提供pages服务，它独立地运行在<a href="http://github.io">http://github.io</a> 域名下<br>创建以 username.github.io 命名的仓库，在里面储存html等文件，就可以生成同域名的网页了（打开速度感人）<br>以本网站为例</p><ul><li><strong>下载node.js</strong>， 脚本语言JavaScript需要一个解析器才能运行，写入html的js语言，浏览器是它的解析器；而对于需要独立运行的JS，nodejs就是一个解析器<br>运行在node.js中的js的用途是操作磁盘文件或搭建http服务器</li><li><strong>通过npm安装模块</strong>，npm是和node.js一起下载的，npm就是JavaScript的包管理工具。类似python中的pip。下面将用它安装hexo等等组件</li><li><strong>通过hexo用markdown语法写html</strong>，相比html，markdown好写得多，hexo是高效的静态站点生成框架，可以直接用markdown语法写博客，而忽略网页的其它细节</li><li><strong>个性化设置</strong>，可以继续安装其它插件，比如本博客的主题hexo-theme-matery</li><li><strong>绑定github</strong>，直到这步，生成的网页都是本地的，通过拓展hexo-deployer-git就可以将生成的html文件上传到username.github.io仓库中，从而使用github的pages服务</li></ul>]]></content>
      
      
      <categories>
          
          <category> how-to系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello_world</title>
      <link href="/2022/01/20/hello-world/"/>
      <url>/2022/01/20/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎！！！"><a href="#欢迎！！！" class="headerlink" title="欢迎！！！"></a>欢迎！！！</h1><p>想着什么时候开始都不算晚，我终于在大二的寒假把自己的博客搭出来了！</p><p><em>筚路蓝缕，以启山林</em></p><p>之后的文章再见吧！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
